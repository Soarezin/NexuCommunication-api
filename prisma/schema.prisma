// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 1. Modelo Tenant (Escritório de Advocacia)
model Tenant {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users   User[]    // Advogados/usuários que pertencem a este Tenant
  clients Client[]  // Clientes que pertencem a este Tenant
  cases   Case[]    // Casos que pertencem a este Tenant
  messages Message[] // Mensagens que ocorrem dentro deste Tenant (para garantir escopo)
  files    File[]    // >>> NOVO: Adicionado para ser o lado oposto da relação com File
}

// 2. Modelo User (Advogados - Usuários do Sistema)
model User {
  id        String   @id @default(uuid())
  firstName String
  lastName  String
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  cases Case[] @relation("LawyerCases")
  sentMessages Message[] @relation("SentByUser")
  // Mensagens recebidas por este advogado (se advogados também recebem mensagens diretamente)
  // Se esta relação 'ReceivedByUser' for para mensagens ENVIADAS POR CLIENTES PARA ADVOGADOS,
  // então o `Message` precisa de um campo 'receiverUserId' e uma relação correspondente.
  // Pelo que entendi, as mensagens são entre User (advogado) e Client (cliente),
  // então esta relação 'receivedMessages' em User talvez não seja necessária aqui,
  // ou precisa de uma lógica clara de quem é o 'receiver' de que tipo de mensagem.
  // POR ENQUANTO, VOU REMOVER ESTE CAMPO PARA SIMPLIFICAR E EVITAR AMBIGUIDADE,
  // JÁ QUE A MENSAGEM FOI DEFINIDA COMO User -> Client.
  // Se você realmente precisar que um advogado "receba" mensagens diretamente,
  // teríamos que ajustar o modelo Message para ter um receiverId opcional que possa ser userId OU clientId.
  // Isso é mais complexo e pode ser um refinamento futuro.
  // Se for o caso, me diga e podemos explorar como fazer isso corretamente.
  // receivedMessages Message[] @relation("ReceivedByUser") // REMOVIDO TEMPORARIAMENTE
}

// 3. Modelo Client (Clientes dos Escritórios de Advocacia)
model Client {
  id          String   @id @default(uuid())
  firstName   String
  lastName    String
  email       String   @unique // Opcional: email pode ser único apenas dentro de um tenant
  phoneNumber String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  cases            Case[]
  receivedMessages Message[] @relation("ReceivedByClient")
}

// 4. Modelo Case (Caso Jurídico)
model Case {
  id          String   @id @default(uuid())
  title       String
  description String?
  status      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  lawyerId String
  lawyer   User   @relation("LawyerCases", fields: [lawyerId], references: [id])

  clientId String
  client   Client @relation(fields: [clientId], references: [id])

  messages Message[]
  files    File[]
}

// 5. Modelo Message (Mensagens)
model Message {
  id        String    @id @default(uuid())
  content   String
  viewed    Boolean   @default(false)
  viewedAt  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  caseId String
  case   Case   @relation(fields: [caseId], references: [id])

  senderId String // Quem enviou a mensagem (um User - advogado)
  sender   User   @relation("SentByUser", fields: [senderId], references: [id])

  receiverClientId String // Quem recebeu a mensagem (um Client)
  receiverClient   Client @relation("ReceivedByClient", fields: [receiverClientId], references: [id])
}

// 6. Modelo File (Arquivos)
model File {
  id         String   @id @default(uuid())
  name       String
  url        String
  uploadedAt DateTime @default(now())

  tenantId String // Garante que o arquivo pertence a um tenant
  tenant   Tenant @relation(fields: [tenantId], references: [id]) // Já existe

  caseId String
  case   Case   @relation(fields: [caseId], references: [id])
}